<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Model Order Reduction in Julia</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Model Order Reduction in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Model Order Reduction in Julia</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><a class="tocitem" href="../supported_formats/">Supported Formats</a></li><li><a class="tocitem" href="../integrators/">Integrators</a></li><li class="is-active"><a class="tocitem" href>Library</a></li><li><a class="tocitem" href="../authors/">Authors</a></li><li><a class="tocitem" href="../literature/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/library_all.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.BE2n" href="#MORFEInvariantManifold.BE2n"><code>MORFEInvariantManifold.BE2n</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Number of nodes of a linear line element (2)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.BE3n" href="#MORFEInvariantManifold.BE3n"><code>MORFEInvariantManifold.BE3n</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Number of nodes of a quadratic line element (3)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.H20n" href="#MORFEInvariantManifold.H20n"><code>MORFEInvariantManifold.H20n</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Number of nodes of a quadratic serendipity hexahedral element (20)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.H27n" href="#MORFEInvariantManifold.H27n"><code>MORFEInvariantManifold.H27n</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Number of nodes of a quadratic Lagrange hexahedral element (27)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.HE8n" href="#MORFEInvariantManifold.HE8n"><code>MORFEInvariantManifold.HE8n</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Number of nodes of a linear hexahedral element (8)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.P15n" href="#MORFEInvariantManifold.P15n"><code>MORFEInvariantManifold.P15n</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Number of nodes of a quadratic 15-nodes wedge element (15)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.P18n" href="#MORFEInvariantManifold.P18n"><code>MORFEInvariantManifold.P18n</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Number of nodes of a quadratic 18-nodes wedge element (18)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.PE6n" href="#MORFEInvariantManifold.PE6n"><code>MORFEInvariantManifold.PE6n</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Number of nodes of a linear wedge element (6)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.QU4n" href="#MORFEInvariantManifold.QU4n"><code>MORFEInvariantManifold.QU4n</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Number of nodes of a linear square element (4)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.QU8n" href="#MORFEInvariantManifold.QU8n"><code>MORFEInvariantManifold.QU8n</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Number of nodes of a quadratic serendipity square element (8)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.QU9n" href="#MORFEInvariantManifold.QU9n"><code>MORFEInvariantManifold.QU9n</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Number of nodes of a quadratic Lagrange square element (9)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.Snse" href="#MORFEInvariantManifold.Snse"><code>MORFEInvariantManifold.Snse</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Number of supported boundary element</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.T10n" href="#MORFEInvariantManifold.T10n"><code>MORFEInvariantManifold.T10n</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Number of nodes of a quadratic tetrahedral element (10)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.TE4n" href="#MORFEInvariantManifold.TE4n"><code>MORFEInvariantManifold.TE4n</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Number of nodes of a linear tetrahedral element (4)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.TR3n" href="#MORFEInvariantManifold.TR3n"><code>MORFEInvariantManifold.TR3n</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Number of nodes of a linear triangular element (3)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.TR6n" href="#MORFEInvariantManifold.TR6n"><code>MORFEInvariantManifold.TR6n</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Number of nodes of a quadratic triangular element (6)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.VE1n" href="#MORFEInvariantManifold.VE1n"><code>MORFEInvariantManifold.VE1n</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Number of nodes of a vertex (1)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.Vnse" href="#MORFEInvariantManifold.Vnse"><code>MORFEInvariantManifold.Vnse</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Number of supported volume element</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.dim" href="#MORFEInvariantManifold.dim"><code>MORFEInvariantManifold.dim</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Dimension of the treated problems (3D)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.ncv_max" href="#MORFEInvariantManifold.ncv_max"><code>MORFEInvariantManifold.ncv_max</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Maximum number of elements connected one to the other</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.nne_max" href="#MORFEInvariantManifold.nne_max"><code>MORFEInvariantManifold.nne_max</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Maximum number nodes for an element</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.ϵ_tol" href="#MORFEInvariantManifold.ϵ_tol"><code>MORFEInvariantManifold.ϵ_tol</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>resonances tolerance</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.Boundary" href="#MORFEInvariantManifold.Boundary"><code>MORFEInvariantManifold.Boundary</code></a> — <span class="docstring-category">Type</span></header><section><div><blockquote><p>mutable struct Boundary</p></blockquote><ul><li>Sen : number of supported elements</li><li>Set : type of supported elements</li><li>Senn : number of nodes of the supported elements</li><li>ne : number of elements of each type in the domain</li><li>e2n : surface element connectivity</li><li>bcdofs : which dofs are constrained</li><li>bcvals : value associated to the boundary condition</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.Domain" href="#MORFEInvariantManifold.Domain"><code>MORFEInvariantManifold.Domain</code></a> — <span class="docstring-category">Type</span></header><section><div><blockquote><p>mutable struct Domain</p></blockquote><ul><li>Sen : number of supported elements</li><li>Set : type of supported elements</li><li>Senn : number of nodes of the supported elements</li><li>ne : number of elements of each type in the domain</li><li>e2n : volume element connectivity</li><li>mat : material associated to the domain</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.Field" href="#MORFEInvariantManifold.Field"><code>MORFEInvariantManifold.Field</code></a> — <span class="docstring-category">Type</span></header><section><div><blockquote><p>mutable struct Field</p></blockquote><ul><li>neq : number of equations</li><li>nen : total number of entries</li><li>cpn : nodal uknowns per node</li><li>dof : dofs ordering</li><li>val : field values</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.Field-Tuple{MORFEInvariantManifold.Grid, Int64}" href="#MORFEInvariantManifold.Field-Tuple{MORFEInvariantManifold.Grid, Int64}"><code>MORFEInvariantManifold.Field</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>Field(mesh::Grid, cpn::Int64)</p></blockquote><p>Field constructor</p><ul><li>mesh : Grid </li><li>cpn : number of nodal unknowns per node</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.Grid" href="#MORFEInvariantManifold.Grid"><code>MORFEInvariantManifold.Grid</code></a> — <span class="docstring-category">Type</span></header><section><div><blockquote><p>mutable struct grid</p></blockquote><ul><li>netype : number of supperted types of elements</li><li>etype : array that stores the number of nodes for each element</li><li>nn : number of nodes</li><li>nΩ : number of domains</li><li>nΓ : number of boundaries</li><li>n2c : nodes coordinates</li><li>Ω : domains</li><li>Γ : boundaries</li><li>tcn : total cells number</li><li>grid() : empty initialization method</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.NodalConnectivity" href="#MORFEInvariantManifold.NodalConnectivity"><code>MORFEInvariantManifold.NodalConnectivity</code></a> — <span class="docstring-category">Type</span></header><section><div><blockquote><p>struct NodalConnectivity</p></blockquote><ul><li>nval : number of nodes + 1</li><li>nreg : total size of the nodal connectivity</li><li>register : bookkeeping nodes to nodes connectivity in compact sparse format</li><li>values : stored node to node connectivity</li><li>maxr : FILL</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.NodalConnectivity-Tuple{MORFEInvariantManifold.Grid}" href="#MORFEInvariantManifold.NodalConnectivity-Tuple{MORFEInvariantManifold.Grid}"><code>MORFEInvariantManifold.NodalConnectivity</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>NodalConnectivity(mesh::Grid)</p></blockquote><p>NodalConnectivity main constructor.</p><ul><li>mesh : Grid</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.Parametrisation" href="#MORFEInvariantManifold.Parametrisation"><code>MORFEInvariantManifold.Parametrisation</code></a> — <span class="docstring-category">Type</span></header><section><div><blockquote><p>mutable struct Parametrisation</p></blockquote><ul><li>nc : number of monomial combinations</li><li>W : mappings [Υ, Ψ]</li><li>f : reduced dynamics</li><li>nlr : nonlinear right hand side</li><li>comb : combinations the system is solved for</li><li>conj : conjugacy relations</li><li>cmap : mapping index combinations</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.material" href="#MORFEInvariantManifold.material"><code>MORFEInvariantManifold.material</code></a> — <span class="docstring-category">Type</span></header><section><div><blockquote><p>struct material</p></blockquote><ul><li>ρ : density of the material</li><li>Dᵢⱼₖₗ : fourth order elasticity tensor in Voigt notation</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.MORFE_mech_autonomous" href="#MORFEInvariantManifold.MORFE_mech_autonomous"><code>MORFEInvariantManifold.MORFE_mech_autonomous</code></a> — <span class="docstring-category">Function</span></header><section><div><blockquote><p>MORFE<em>mech</em>autonomous(mesh<em>file,domains</em>list,materials,boundaries<em>list,constrained</em>dof,bc<em>vals,α,β,Φₗᵢₛₜ,style,max</em>order,neig=0,nls=0)</p></blockquote><p>Parametrisation of the autonomous system:</p><p class="math-container">\[\mathbf{M}\ddot{\mathbf{U}}+\mathbf{C}\dot{\mathbf{U}}+\mathbf{F(\mathbf{U})}=0\]</p><ul><li>mesh_file : name of the mesh file with extension</li><li>domains_list : tags of domains included in the analysis</li><li>materials : materials associated to each domain</li><li>boundaries_list : list of all boundaries included in the analysis</li><li>constrained_dof : list of constrained degrees of freedom</li><li>bc_vals : value of the boundary condition</li><li>α : mass-proportional damping coefficient</li><li>β : stiffness-proportional damping coefficient</li><li>Φₗᵢₛₜ : list of the master modes included in the analysis</li><li>style : parametrisation style</li><li>max_order : maximum order of the asymptotic development</li><li>neig : number of eigenvalues. If not used, then neig = maximum(Φₗᵢₛₜ)</li><li>nls : nonlinear static analysis. 0 = no, 1 = yes.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.MORFE_mech_nonautonomous" href="#MORFEInvariantManifold.MORFE_mech_nonautonomous"><code>MORFEInvariantManifold.MORFE_mech_nonautonomous</code></a> — <span class="docstring-category">Function</span></header><section><div><blockquote><p>MORFE<em>mech</em>autonomous(mesh<em>file,domains</em>list,materials,boundaries<em>list,constrained</em>dof,bc<em>vals,Ω</em>list,κ<em>modes,κ</em>list,κ<em>phase,α,β,Φₗᵢₛₜ,style,max</em>order<em>a,max</em>order_na,neig=0,nls=0)</p></blockquote><p>Parametrisation of the autonomous system:</p><p class="math-container">\[\mathbf{M}\ddot{\mathbf{U}}+\mathbf{C}\dot{\mathbf{U}}+\mathbf{F(\mathbf{U})}=\mathbf{F}(t)\]</p><ul><li>mesh_file : name of the mesh file with extension</li><li>domains_list : tags of domains included in the analysis</li><li>materials : materials associated to each domain</li><li>boundaries_list : list of all boundaries included in the analysis</li><li>constrained_dof : list of constrained degrees of freedom</li><li>bc_vals : value of the boundary condition</li><li>Ω_list : list of forcing frequencies</li><li>κ_modes : load multiplier associated to each forcing term</li><li>κ_list : shape of each forcing</li><li>κ_phase : identification of the forcing phase. &quot;c&quot; = cosine, &quot;s&quot; = sine</li><li>α : mass-proportional damping coefficient</li><li>β : stiffness-proportional damping coefficient</li><li>Φₗᵢₛₜ : list of the master modes included in the analysis</li><li>style : parametrisation style</li><li>max_order : maximum order of the asymptotic development</li><li>neig : number of eigenvalues. If not used, then neig = maximum(Φₗᵢₛₜ)</li><li>nls : nonlinear static analysis. 0 = no, 1 = yes.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.N!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:H20}}}" href="#MORFEInvariantManifold.N!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:H20}}}"><code>MORFEInvariantManifold.N!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>N!(N::Array{Float64},gp::Tuple,::Type{Val{:H20}})</p></blockquote><p>It fills N with the shape functions of a PE6 element evaluated at gauss point gp.</p><ul><li>N : shape functions Array</li><li>gp : gauss point coordinates</li><li>:Type{Val{:H20}} : element type specifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.N!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:H27}}}" href="#MORFEInvariantManifold.N!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:H27}}}"><code>MORFEInvariantManifold.N!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>N!(N::Array{Float64},gp::Tuple,::Type{Val{:H27}})</p></blockquote><p>It fills N with the shape functions of a PE6 element evaluated at gauss point gp.</p><ul><li>N : shape functions Array</li><li>gp : gauss point coordinates</li><li>:Type{Val{:H27}} : element type specifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.N!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:HE8}}}" href="#MORFEInvariantManifold.N!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:HE8}}}"><code>MORFEInvariantManifold.N!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>N!(N::Array{Float64},gp::Tuple,::Type{Val{:HE8}})</p></blockquote><p>It fills N with the shape functions of a H8 element evaluated at gauss point gp.</p><ul><li>N : shape functions Array</li><li>gp : gauss point coordinates</li><li>:Type{Val{:HE8}} : element type specifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.N!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:P15}}}" href="#MORFEInvariantManifold.N!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:P15}}}"><code>MORFEInvariantManifold.N!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>N!(N::Array{Float64},gp::Tuple,::Type{Val{:P15}})</p></blockquote><p>It fills N with the shape functions of a PE6 element evaluated at gauss point gp.</p><ul><li>N : shape functions Array</li><li>gp : gauss point coordinates</li><li>:Type{Val{:P15}} : element type specifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.N!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:P18}}}" href="#MORFEInvariantManifold.N!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:P18}}}"><code>MORFEInvariantManifold.N!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>N!(N::Array{Float64},gp::Tuple,::Type{Val{:P18}})</p></blockquote><p>It fills N with the shape functions of a PE6 element evaluated at gauss point gp.</p><ul><li>N : shape functions Array</li><li>gp : gauss point coordinates</li><li>:Type{Val{:P18}} : element type specifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.N!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:PE6}}}" href="#MORFEInvariantManifold.N!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:PE6}}}"><code>MORFEInvariantManifold.N!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>N!(N::Array{Float64},gp::Tuple,::Type{Val{:PE6}})</p></blockquote><p>It fills N with the shape functions of a PE6 element evaluated at gauss point gp.</p><ul><li>N : shape functions Array</li><li>gp : gauss point coordinates</li><li>:Type{Val{:PE6}} : element type specifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.N!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:T10}}}" href="#MORFEInvariantManifold.N!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:T10}}}"><code>MORFEInvariantManifold.N!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>N!(N::Array{Float64},gp::Tuple,::Type{Val{:T10}})</p></blockquote><p>It fills N with the shape functions of a T10 element evaluated at gauss point gp.</p><ul><li>N : shape functions Array</li><li>gp : gauss point coordinates</li><li>:Type{Val{:T10}} : element type specifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.N!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:TE4}}}" href="#MORFEInvariantManifold.N!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:TE4}}}"><code>MORFEInvariantManifold.N!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>N!(N::Array{Float64},gp::Tuple,::Type{Val{:TE4}})</p></blockquote><p>It fills N with the shape functions of a T4 element evaluated at gauss point gp.</p><ul><li>N : shape functions Array</li><li>gp : gauss point coordinates</li><li>:Type{Val{:TE4}} : element type specifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.N27!-Tuple{Array{Float64, N} where N, Tuple}" href="#MORFEInvariantManifold.N27!-Tuple{Array{Float64, N} where N, Tuple}"><code>MORFEInvariantManifold.N27!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>N!(N::Array{Float64},gp::Tuple,::Type{Val{:H27}})</p></blockquote><p>It fills N with the shape functions of a PE6 element evaluated at gauss point gp.</p><ul><li>N : shape functions Array</li><li>gp : gauss point coordinates</li><li>:Type{Val{:H27}} : element type specifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.add_material-Tuple{String, Float64, Float64, Float64}" href="#MORFEInvariantManifold.add_material-Tuple{String, Float64, Float64, Float64}"><code>MORFEInvariantManifold.add_material</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>add_material( name::String, ρ::Float64, E::Float64, ν::Float64 )</p></blockquote><p>It adds an isotropic material to the internal database of the package.</p><ul><li>name = name of the material</li><li>ρ = density of the material</li><li>E = Young&#39;s modulus </li><li>ν = Poisson&#39;s ratio</li></ul><p><strong>return</strong>  <em>nothing</em></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.add_material-Tuple{String, Float64, Matrix{Float64}}" href="#MORFEInvariantManifold.add_material-Tuple{String, Float64, Matrix{Float64}}"><code>MORFEInvariantManifold.add_material</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>add_material( name::String, ρ::Float64, Dᵢⱼₖₗ::Matrix{Float64} )</p></blockquote><p>It adds an anisotropic material to the internal database of the package.</p><ul><li>name = name of the material</li><li>ρ = density of the material</li><li>Dᵢⱼₖₗ = fourth order elasticity tensor</li></ul><p><strong>return</strong>  <em>nothing</em></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.append_rdyn_frequency!-Tuple{Any, Any, Any}" href="#MORFEInvariantManifold.append_rdyn_frequency!-Tuple{Any, Any, Any}"><code>MORFEInvariantManifold.append_rdyn_frequency!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>append<em>rdyn</em>frequency!(rdyn,ndofs,ith_Ω)</p></blockquote><p>It appends auxiliary variables required to recast the non-autonomous reduced dynamics as autonomous</p><ul><li>rdyn : reduced dynamics</li><li>ndofs : number of degrees of freedom</li><li>ith_Ω : integer represeting which excitation frequency you are exciting</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.assembly!-Tuple{SparseArrays.SparseMatrixCSC, Float64, Int64, Int64}" href="#MORFEInvariantManifold.assembly!-Tuple{SparseArrays.SparseMatrixCSC, Float64, Int64, Int64}"><code>MORFEInvariantManifold.assembly!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>assembly!(K::SparseMatrixCSC, val::Float64, ir::Int64, jc::Int64)</p></blockquote><p>Assembly value in sparse matrix using binary search</p><ul><li>K : global matrix </li><li>val : value to assemble</li><li>ir : row entry</li><li>jc : column entry</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.assembly_G_nl!" href="#MORFEInvariantManifold.assembly_G_nl!"><code>MORFEInvariantManifold.assembly_G_nl!</code></a> — <span class="docstring-category">Function</span></header><section><div><blockquote><p>assembly<em>G</em>nl!(Cp, entry,Ψ₁, Ψ₂,mesh, U, mult = 1.0)</p></blockquote><p>It assemblies quadratic nonlinearities operator</p><p>$ G(Ψ₁,Ψ₂) = \frac{1}{2} ∫_{Ω} γ(Ψ₁,Ψ₂):\mathcal{A}:ε(w) + γ(Ψ₁,w):\mathcal{A}:ε(Ψ₂) + γ(w,Ψ₂):\mathcal{A}:ε(Ψ₁) dΩ $</p><ul><li>Cp : parametrisation data structure</li><li>entry : entrance of the reference array</li><li>Ψ₁ : mapping</li><li>Ψ₂ : mapping</li><li>mesh : mesh data structure</li><li>U : displacement field</li><li>mult : integral multiplier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.assembly_H_nl!" href="#MORFEInvariantManifold.assembly_H_nl!"><code>MORFEInvariantManifold.assembly_H_nl!</code></a> — <span class="docstring-category">Function</span></header><section><div><blockquote><p>assembly<em>H</em>nl!(Cp, entry,Ψ₁, Ψ₂, Ψ₃,mesh, U, mult = 1.0)</p></blockquote><p>It assemblies cubic nonlinearities operator</p><p>$ G(Ψ₁,Ψ₂,Ψ₃) = \frac{1}{6} ∫_{Ω} γ(Ψ₁,Ψ₂):\mathcal{A}:γ(Ψ₃,w) + γ(Ψ₁,Ψ₃):\mathcal{A}:γ(Ψ₂,w) + γ(Ψ₃,Ψ₂):\mathcal{A}:γ(Ψ₁,w) dΩ $</p><ul><li>Cp : parametrisation data structure</li><li>entry : entrance of the reference array</li><li>Ψ₁ : mapping</li><li>Ψ₂ : mapping</li><li>Ψ₃ : mapping</li><li>mesh : mesh data structure</li><li>U : displacement field</li><li>mult : integral multiplier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.assembly_MCK!-Tuple{MORFEInvariantManifold.Grid, MORFEInvariantManifold.Field, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Float64, Float64}" href="#MORFEInvariantManifold.assembly_MCK!-Tuple{MORFEInvariantManifold.Grid, MORFEInvariantManifold.Field, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Float64, Float64}"><code>MORFEInvariantManifold.assembly_MCK!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>assembly_MCK!(mesh::Grid, U::Field, M::SparseMatrixCSC, C::SparseMatrixCSC, K::SparseMatrixCSC, α::Float64, β::Float64)</p></blockquote><p>It assemblies mass, damping, and stiffness matrices</p><ul><li>mesh : Grid </li><li>U : displacement field</li><li>M : mass matrix</li><li>C : damping matrix</li><li>K : stiffness matrix</li><li>α : Rayleigh damping mass proportional coefficient</li><li>β : Rayleigh damping stiffness proportional coefficient</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.assembly_cubic_nl!-NTuple{7, Any}" href="#MORFEInvariantManifold.assembly_cubic_nl!-NTuple{7, Any}"><code>MORFEInvariantManifold.assembly_cubic_nl!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>assembly<em>cubic</em>nl!(Cp,entry,ic,ndofs,p,mesh,U)</p></blockquote><p>It assembles cubic nonlinearities vector for a given monomial I of order p</p><ul><li>Cp : parametrisation data structure</li><li>entry : index entry </li><li>ic : index combination of the monomial</li><li>ndofs : number or degrees of freedom</li><li>p : order of the asymptotic development</li><li>mesh : grid data structure</li><li>U : displacement field</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.assembly_cubic_nl_veps!-NTuple{8, Any}" href="#MORFEInvariantManifold.assembly_cubic_nl_veps!-NTuple{8, Any}"><code>MORFEInvariantManifold.assembly_cubic_nl_veps!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>assembly<em>cubic</em>nl_veps!(Cp,Cp⁺,entry,Cic,ndofs,p,mesh,U)</p></blockquote><p>It computes cubic nonlinearity vectors for all monomials of order p of the non-autonomous asymptotic development</p><ul><li>Cp : autonomous parametrisation data structure</li><li>Cp⁺ :  non-auonomous parametrisation data structure</li><li>entry : array entry of a given monomial</li><li>ic : index combination associated to a monomial</li><li>ndofs : number of degrees of freedom</li><li>p : order of the asymptotic development</li><li>mesh : grid data structure</li><li>U : displacement field</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.assembly_forcing_vector!-Tuple{MORFEInvariantManifold.Parametrisation, MORFEInvariantManifold.Grid, MORFEInvariantManifold.Field, Any, Any, Any, Any, Any}" href="#MORFEInvariantManifold.assembly_forcing_vector!-Tuple{MORFEInvariantManifold.Parametrisation, MORFEInvariantManifold.Grid, MORFEInvariantManifold.Field, Any, Any, Any, Any, Any}"><code>MORFEInvariantManifold.assembly_forcing_vector!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>assembly<em>forcing</em>vector!(Cp⁺,mesh,U,M,ϕ,κ<em>modes,κ</em>list,κ_phase)</p></blockquote><p>It assemblies the non-autonomous forcing vector</p><p>$ \mathbf{F} = ∑_{i=1}^{N} κᵢMϕᵢ $</p><ul><li>Cp⁺ : no-autonomous parametrisation data structure</li><li>mesh : mesh data structure</li><li>U : displacement field</li><li>M : mass matrix</li><li>ϕ : eigenmodes</li><li>κ_modes : list of forced modes</li><li>κ_list : forcing amplitude κᵢ</li><li>κ_phase : phase of the applied forcing</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.assembly_mat_sym!-Tuple{SparseArrays.SparseMatrixCSC, Matrix{Float64}, Array{Int64, N} where N, Int64}" href="#MORFEInvariantManifold.assembly_mat_sym!-Tuple{SparseArrays.SparseMatrixCSC, Matrix{Float64}, Array{Int64, N} where N, Int64}"><code>MORFEInvariantManifold.assembly_mat_sym!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>assembly<em>mat</em>sym!(K::SparseMatrixCSC,Kₑ::Matrix{Float64},dofs::Array{Int64},rl::Int64)</p></blockquote><p>It assembles elemental matrices into sparse matrices. Is assumes CSC format with lower triangular.</p><ul><li>K : global matrix </li><li>Kₑ : elemental matrix</li><li>dofs : degrees of freedom </li><li>rl : row length</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.assembly_quadratic_nl!-NTuple{8, Any}" href="#MORFEInvariantManifold.assembly_quadratic_nl!-NTuple{8, Any}"><code>MORFEInvariantManifold.assembly_quadratic_nl!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>assembly<em>quadratic</em>nl!(Cp,entry,ic,ndofs,p,mesh,U,nls)</p></blockquote><p>It assembles quadratic nonlinearities vector for a given monomial I of order p</p><ul><li>Cp : parametrisation data structure</li><li>entry : index entry </li><li>ic : index combination of the monomial</li><li>ndofs : number or degrees of freedom</li><li>p : order of the asymptotic development</li><li>mesh : grid data structure</li><li>U : displacement field</li><li>nls : tag for nonlinear static analysis. 0 = no, 1 = yes</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.assembly_quadratic_nl_veps!-NTuple{9, Any}" href="#MORFEInvariantManifold.assembly_quadratic_nl_veps!-NTuple{9, Any}"><code>MORFEInvariantManifold.assembly_quadratic_nl_veps!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>assembly<em>cubic</em>nl_veps!(Cp,Cp⁺,entry,Cic,ndofs,p,mesh,U)</p></blockquote><p>It computes quadratic nonlinearity vectors for all monomials of order p of the non-autonomous asymptotic development</p><ul><li>Cp : autonomous parametrisation data structure</li><li>Cp⁺ :  non-auonomous parametrisation data structure</li><li>entry : array entry of a given monomial</li><li>ic : index combination associated to a monomial</li><li>ndofs : number of degrees of freedom</li><li>p : order of the asymptotic development</li><li>mesh : grid data structure</li><li>U : displacement field</li><li>nls : nonlinear static solution. 0 = no, 1 = yes</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.assembly_sys_mat!-NTuple{8, Any}" href="#MORFEInvariantManifold.assembly_sys_mat!-NTuple{8, Any}"><code>MORFEInvariantManifold.assembly_sys_mat!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>assembly<em>sys</em>mat!(Cp,sys<em>mat,M,C,K,σ,resonant</em>modes,ndofs)</p></blockquote><p>it assembles the linear system associated to a homological equation</p><ul><li>Cp : parametrisation structure</li><li>sys_mat : matrix associated to the homological equation</li><li>M : mass matrix</li><li>C : damping matrix</li><li>K : stiffness matrix</li><li>σ : summation of eigenvalues λ</li><li>resonant_modes : book-keeping of the set R of resonant modes</li><li>ndofs : number of degrees of freedom</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.assembly_sys_rhs!-NTuple{10, Any}" href="#MORFEInvariantManifold.assembly_sys_rhs!-NTuple{10, Any}"><code>MORFEInvariantManifold.assembly_sys_rhs!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>assembly<em>sys</em>rhs!(Cp,sys<em>rhs,sys</em>res,M,C,comb,p,ndofs,σ,resonant_modes)</p></blockquote><p>It assembles the right hand side of a given homological equation of the ε⁰-developmet</p><ul><li>Cp : parametrisation structure</li><li>sys_rhs : right hand side of the homological equations</li><li>sys_res : residual of the homological equations</li><li>M : mass matrix</li><li>C : damping matrix</li><li>comb : reference monomial index</li><li>p : order of the asymptotic development</li><li>ndofs : number of degrees of freedom</li><li>σ : eingevalues λ summation</li><li>resonant_modes : book-keeping of the set R of resonant modes</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.assembly_sys_rhs_veps!-NTuple{11, Any}" href="#MORFEInvariantManifold.assembly_sys_rhs_veps!-NTuple{11, Any}"><code>MORFEInvariantManifold.assembly_sys_rhs_veps!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>assembly<em>sys</em>rhs!(Cp,Cp⁺,sys<em>rhs,sys</em>res,M,C,comb,p,ndofs,σ,resonant_modes)</p></blockquote><p>It assembles the right hand side of a given homological equation of the ε⁰-developmet</p><ul><li>Cp : autonomous parametrisation data structure</li><li>Cp⁺ :  non-auonomous parametrisation data structure</li><li>sys_rhs : right hand side of the homological equations</li><li>sys_res : residual of the homological equations</li><li>M : mass matrix</li><li>C : damping matrix</li><li>comb : reference monomial index</li><li>p : order of the asymptotic development</li><li>ndofs : number of degrees of freedom</li><li>σ : eingevalues λ summation</li><li>resonant_modes : book-keeping of the set R of resonant modes</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.assembly_μ_ν_resid!-NTuple{6, Any}" href="#MORFEInvariantManifold.assembly_μ_ν_resid!-NTuple{6, Any}"><code>MORFEInvariantManifold.assembly_μ_ν_resid!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>assembly<em>μ</em>ν_resid!(Cp,entry,ic,ndofs,p,neq)</p></blockquote><p>It assembles μ and ν for a given monomial I of order p for the ε⁰ development. </p><ul><li>Cp : parametrisation data structure</li><li>entry : entry associated to a monomial combination</li><li>ic : monomial index combination</li><li>ndofs : number of degrees of freedom</li><li>p : order of the asymptotic development</li><li>neq : number of equations</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.assembly_μ_ν_resid_veps!-NTuple{7, Any}" href="#MORFEInvariantManifold.assembly_μ_ν_resid_veps!-NTuple{7, Any}"><code>MORFEInvariantManifold.assembly_μ_ν_resid_veps!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>recursive<em>assembly</em>veps!(Cp,Cp⁺,ndofs,p,mesh,U,Cic,cc,nls=0)</p></blockquote><p>It assembles right hand sides of all homological equations for a given order p of the expansion.</p><ul><li>Cp : autonomous parametrisation data structure</li><li>Cp⁺ :  non-auonomous parametrisation data structure</li><li>entry : array entry of a given monomial</li><li>ic : index combination associated to a monomial</li><li>ndofs : number of degrees of freedom</li><li>p : order of the asymptotic development</li><li>neq : number of equations</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.check_resonances!-NTuple{5, Any}" href="#MORFEInvariantManifold.check_resonances!-NTuple{5, Any}"><code>MORFEInvariantManifold.check_resonances!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>check<em>resonances!(Cp,σ,ndofs,style,resonant</em>modes)</p></blockquote><p>It checks which mode is resonant. It complies with the chosen style.</p><ul><li>Cp : parametrisation data structure</li><li>σ : summation of eigenvalues λ</li><li>ndofs : number of degrees of freedom</li><li>style : parametrisation style</li><li>resonant_modes : book-keeping of the set R of resonant modes</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.compute_ncomb-Tuple{Int64, Int64}" href="#MORFEInvariantManifold.compute_ncomb-Tuple{Int64, Int64}"><code>MORFEInvariantManifold.compute_ncomb</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>compute_ncomb(param,order,ndofs,neq)</p></blockquote><p>It computes the monomials combinations that need to be computed</p><ul><li>p : order of the expansion</li><li>ndofs : number of degrees of freedom of the reduced model</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.delete_material-Tuple{String}" href="#MORFEInvariantManifold.delete_material-Tuple{String}"><code>MORFEInvariantManifold.delete_material</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>delete_materials()</p></blockquote><p>It delets a material in the database.</p><ul><li>name = name of the material to delete</li></ul><p><strong>return</strong>  <em>nothing</em></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.dofs!-Tuple{MORFEInvariantManifold.Field, Int64, SubArray{Int64, 1, Vector{Int64}, Tuple{UnitRange{Int64}}, true}, Vector{Int64}}" href="#MORFEInvariantManifold.dofs!-Tuple{MORFEInvariantManifold.Field, Int64, SubArray{Int64, 1, Vector{Int64}, Tuple{UnitRange{Int64}}, true}, Vector{Int64}}"><code>MORFEInvariantManifold.dofs!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>dofs!(ϕ::Field, nn::Int64, nodes::SubArray{Int64, 1, Vector{Int64}, Tuple{UnitRange{Int64}}, dofs::Vector{nt64})</p></blockquote><p>It copies the dofs associated to nodes list nodes into dofs. This version accepts SubArrays.</p><ul><li>ϕ : field of interest </li><li>nn : number of queries</li><li>nodes : list of nodes</li><li>dofs : number of degrees of freedom</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.dofs!-Tuple{MORFEInvariantManifold.Field, Int64, Vector{Int64}, Vector{Int64}}" href="#MORFEInvariantManifold.dofs!-Tuple{MORFEInvariantManifold.Field, Int64, Vector{Int64}, Vector{Int64}}"><code>MORFEInvariantManifold.dofs!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>dofs!(ϕ::Field, nn::Int64, nodes::Vector{Int64}, dofs::Vector{nt64})</p></blockquote><p>It copies the dofs associated to nodes list nodes into dofs.</p><ul><li>ϕ : field of interest </li><li>nn : number of queries</li><li>nodes : list of nodes</li><li>dofs : number of degrees of freedom</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.dofs_vals!-Tuple{MORFEInvariantManifold.Field, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}" href="#MORFEInvariantManifold.dofs_vals!-Tuple{MORFEInvariantManifold.Field, Int64, Vector{Int64}, Vector{Int64}, Vector{Float64}}"><code>MORFEInvariantManifold.dofs_vals!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>dofs_vals!(ϕ::Field, nn::Int64, nodes::Vector{Int64}, dofs::Vector{Int64}, vals::Vector{Float64})</p></blockquote><p>It copies the dofs and values associated to nodes list nodes into dofs and vals.</p><ul><li>ϕ : field of interest </li><li>nn : number of queries</li><li>nodes : list of nodes</li><li>dofs : number of degrees of freedom</li><li>vals : values of the field</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.export_C-Tuple{Any, Any, Any}" href="#MORFEInvariantManifold.export_C-Tuple{Any, Any, Any}"><code>MORFEInvariantManifold.export_C</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>export_C(odir,coeff,ndofs)</p></blockquote><p>it saves the monomials exponents.</p><ul><li>odir : output directory</li><li>coeff : exponents of the monomial</li><li>ndofs : number of degrees of freedom of the reduced model</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.export_M-NTuple{6, Any}" href="#MORFEInvariantManifold.export_M-NTuple{6, Any}"><code>MORFEInvariantManifold.export_M</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>export_M(Wr,comb,odir,M,Φ,neig)</p></blockquote><p>it saves the mass-wieighted projections of the mappings onto the computed modal basis.</p><ul><li>Wr : realified mapping of order p</li><li>comb : saved index combination</li><li>odir : output directory</li><li>M : mass-matrix</li><li>Φ : eigenmodes</li><li>neig : number of computed eigenmodes</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.export_W-NTuple{4, Any}" href="#MORFEInvariantManifold.export_W-NTuple{4, Any}"><code>MORFEInvariantManifold.export_W</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>export<em>W(Ψ,Υ,coeff,U,odir</em>W)</p></blockquote><p>it saves the realified mappings</p><ul><li>Ψ : realified displacement mapping</li><li>Υ : realified velocity mapping</li><li>odir : output directory</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.export_data!-NTuple{13, Any}" href="#MORFEInvariantManifold.export_data!-NTuple{13, Any}"><code>MORFEInvariantManifold.export_data!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>export<em>data!(Cp,Wr,fr,p,ndofs,U,M,Φ,neig,odir</em>C,odir<em>W,odir</em>f,odir_M)</p></blockquote><p>It saves the output of a given order of the parametrisation procedure. Only realified quantities are saved.</p><ul><li>Cp : order p of a given parametrisation</li><li>Wr : realified mapping of order p</li><li>fr : realified reduced dynamics of order p</li><li>p : order of the asymptotic expansion</li><li>ndofs : number of degrees of freedom</li><li>U : displacement field</li><li>M : mass matrix</li><li>Φ : eigenmodes list</li><li>neig : number of computed eigenvalues</li><li>odir_C : path to the folder that stores monomials exponents</li><li>odir_W : path to the folder that stores the realified mappings</li><li>odir_f : path to the folder that stores the realified reduced dynamics</li><li>odir_M : path to the folder that stores the mass-wiedghted projected mappings onto the computed modes</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.export_data_veps!-NTuple{17, Any}" href="#MORFEInvariantManifold.export_data_veps!-NTuple{17, Any}"><code>MORFEInvariantManifold.export_data_veps!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>export<em>data</em>veps!(Cp,Wr,fr,p,ndofs,U,M,Φ,neig,odir<em>C</em>c, odir<em>W</em>c, odir<em>f</em>c, odir<em>M</em>c, odir<em>C</em>s, odir<em>W</em>s, odir<em>f</em>s, odir<em>M</em>s)</p></blockquote><p>It saves the output of a given order of the non-autonomous parametrisation procedure. Only realified quantities are saved.</p><ul><li>Cp : order p of a given parametrisation</li><li>Wr : realified mapping of order p</li><li>fr : realified reduced dynamics of order p</li><li>p : order of the asymptotic expansion</li><li>ndofs : number of degrees of freedom</li><li>U : displacement field</li><li>M : mass matrix</li><li>Φ : eigenmodes list</li><li>neig : number of computed eigenvalues</li><li>odir<em>C</em>c : path to the folder that stores monomials exponents, cosine harmonic</li><li>odir<em>W</em>c : path to the folder that stores the realified mappings, cosine harmonic</li><li>odir<em>f</em>c : path to the folder that stores the realified reduced dynamics, cosine harmonic</li><li>odir<em>M</em>c : path to the folder that stores the mass-wiedghted projected mappings onto the computed modes, cosine harmonic</li><li>odir<em>C</em>s : path to the folder that stores monomials exponents, sine harmonic</li><li>odir<em>W</em>s : path to the folder that stores the realified mappings, sine harmonic</li><li>odir<em>f</em>s : path to the folder that stores the realified reduced dynamics, sine harmonic</li><li>odir<em>M</em>s : path to the folder that stores the mass-wiedghted projected mappings onto the computed modes, sine harmonic</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.export_eig-Tuple{MORFEInvariantManifold.Grid, MORFEInvariantManifold.Field, Vector{Float64}, Matrix{Float64}, String, Int64}" href="#MORFEInvariantManifold.export_eig-Tuple{MORFEInvariantManifold.Grid, MORFEInvariantManifold.Field, Vector{Float64}, Matrix{Float64}, String, Int64}"><code>MORFEInvariantManifold.export_eig</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>export<em>eig(mesh</em>file::String, U::field<em>type, λ::Vector{ComplexF64},ϕ::Matrix{ComplexF64},out</em>dir::String)</p></blockquote><p>It exports the eigenfunctions in vtk format and eigenfrequencies in .txt file</p><ul><li>mesh_file : name of the mesh file</li><li>U : dummy field variable</li><li>λ : eigenvalues</li><li>ϕ : eigenfunctions</li><li>out_dir : output directory</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.export_f-Tuple{Any, Any, Any}" href="#MORFEInvariantManifold.export_f-Tuple{Any, Any, Any}"><code>MORFEInvariantManifold.export_f</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>export_f(fr,ndofs,odir)</p></blockquote><p>it saves the realified reduced dynamics.</p><ul><li>fr : realified reduced dynamics vector</li><li>ndofs : number of degrees of freedom of the reduced model</li><li>odir : output directory</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.fill_comb!-Tuple{Matrix{Int64}, Array{Int64, N} where N, Int64, Int64, Array{Int64, N} where N, Int64, Int64}" href="#MORFEInvariantManifold.fill_comb!-Tuple{Matrix{Int64}, Array{Int64, N} where N, Int64, Int64, Array{Int64, N} where N, Int64, Int64}"><code>MORFEInvariantManifold.fill_comb!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>fill<em>comb!(comb::Matrix{Int64},cmap::Array{Int64},ndofs::Int64,p::Int64,combs::Array{Int64},ith</em>c::Int64,counter::Int64)</p></blockquote><p>It fills the comb matrix with the associated exponentials</p><ul><li>comb : matrix that stores the powers of the monomials</li><li>cmap : total combinations map</li><li>ndofs : number of degrees of freedom</li><li>p : order of the asymptotic expansion</li><li>combs : combinations</li><li>ith_c : ith-combination</li><li>counter : recursion depth</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.fill_mapping!-NTuple{5, Any}" href="#MORFEInvariantManifold.fill_mapping!-NTuple{5, Any}"><code>MORFEInvariantManifold.fill_mapping!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>fill_mapping!(Ψ,Υ,Wr,e,U)</p></blockquote><p>it copies the mappings but taking into account the global nodes ordering</p><ul><li>Ψ : realified displacement mapping</li><li>Υ : realified velocity mapping</li><li>Wr : realified mapping</li><li>e : combination index</li><li>U : displacement field</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.fill_mapping_c!-NTuple{5, Any}" href="#MORFEInvariantManifold.fill_mapping_c!-NTuple{5, Any}"><code>MORFEInvariantManifold.fill_mapping_c!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>fill_mapping!(Ψ,Υ,Wr,e,U)</p></blockquote><p>it copies the mappings but taking into account the global nodes ordering. Cosine variant.</p><ul><li>Ψ : realified displacement mapping</li><li>Υ : realified velocity mapping</li><li>Wr : realified mapping</li><li>e : combination index</li><li>U : displacement field</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.fill_mapping_s!-NTuple{5, Any}" href="#MORFEInvariantManifold.fill_mapping_s!-NTuple{5, Any}"><code>MORFEInvariantManifold.fill_mapping_s!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>fill_mapping!(Ψ,Υ,Wr,e,U)</p></blockquote><p>it copies the mappings but taking into account the global nodes ordering. Since variant.</p><ul><li>Ψ : realified displacement mapping</li><li>Υ : realified velocity mapping</li><li>Wr : realified mapping</li><li>e : combination index</li><li>U : displacement field</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.fill_rdyn!-NTuple{5, Any}" href="#MORFEInvariantManifold.fill_rdyn!-NTuple{5, Any}"><code>MORFEInvariantManifold.fill_rdyn!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>init_rdyn(ndofs)</p></blockquote><p>It initializes the real-valued reduced dynamics in a format compatible with MATCONT</p><ul><li>ndofs : number of degrees of freedom</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.fill_rdyn_c!-NTuple{4, Any}" href="#MORFEInvariantManifold.fill_rdyn_c!-NTuple{4, Any}"><code>MORFEInvariantManifold.fill_rdyn_c!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>fill<em>rdyn</em>c!(rdyn,fr,i,ndofs)</p></blockquote><p>Harmonics realification step. Cosine variant.</p><ul><li>rdyn : realified reduced dynamics</li><li>fr : reduced dynamics</li><li>i : index combination</li><li>ndofs : number of degrees of freedom</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.fill_rdyn_s!-NTuple{4, Any}" href="#MORFEInvariantManifold.fill_rdyn_s!-NTuple{4, Any}"><code>MORFEInvariantManifold.fill_rdyn_s!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>fill<em>rdyn</em>s!(rdyn,fr,i,ndofs)</p></blockquote><p>Harmonics realification step. Sine variant.</p><ul><li>rdyn : realified reduced dynamics</li><li>fr : reduced dynamics</li><li>i : index combination</li><li>ndofs : number of degrees of freedom</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.fill_rdyn_veps!-NTuple{6, Any}" href="#MORFEInvariantManifold.fill_rdyn_veps!-NTuple{6, Any}"><code>MORFEInvariantManifold.fill_rdyn_veps!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>fill<em>rdyn</em>veps!(rdyn,ndofs,fr,Cp,p,ith_Ω)</p></blockquote><ul><li>rdyn : reduced dynamics</li><li>ndofs : number of degrees of freedom</li><li>fr : realified reduced dynamics</li><li>Cp : parametrisation of order p</li><li>p : order of the asymptotic development</li><li>ith_Ω : integer represeting which excitation frequency you are exciting</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.find_index_global-Tuple{Any, Any, Any}" href="#MORFEInvariantManifold.find_index_global-Tuple{Any, Any, Any}"><code>MORFEInvariantManifold.find_index_global</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>find<em>index</em>global(combs,ndofs,p)</p></blockquote><p>It computes the position in the cmap array of a given combination</p><ul><li>combs : total combinations</li><li>ndofs : number of degrees of freedom</li><li>p : order of the expansion</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.find_index_map-Tuple{Int64, Int64, Int64, Int64, Int64, Array{Int64, N} where N}" href="#MORFEInvariantManifold.find_index_map-Tuple{Int64, Int64, Int64, Int64, Int64, Array{Int64, N} where N}"><code>MORFEInvariantManifold.find_index_map</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>find<em>index</em>map(j::Int64,k::Int64,s::Int64,p::Int64,ndofs::Int64,index_comb::Array{Int64})</p></blockquote><p>It finds the position of a map for a certain index_comb during time-derivatives residual calculation.</p><ul><li>j : counter</li><li>k : counter</li><li>s : counter</li><li>p : expansion order</li><li>ndofs : number of degrees of freedom</li><li>index_comb : reference monomials exponentials</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.find_index_rdyn-Tuple{Int64, Int64, Int64, Array{Int64, N} where N}" href="#MORFEInvariantManifold.find_index_rdyn-Tuple{Int64, Int64, Int64, Array{Int64, N} where N}"><code>MORFEInvariantManifold.find_index_rdyn</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>find<em>index</em>rdyn(j::Int64,k::Int64,ndofs::Int64,index_comb::Array{Int64})</p></blockquote><p>It finds the position of a reduced dynamics vector for a certain index_comb during time-derivatives residual calculation.</p><ul><li>j : counter</li><li>k : counter</li><li>ndofs : number of degrees of freedom</li><li>index_comb : reference monomials exponentials</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.find_position_g-Tuple{Int64, Int64, Int64, Array{Int64, N} where N}" href="#MORFEInvariantManifold.find_position_g-Tuple{Int64, Int64, Int64, Array{Int64, N} where N}"><code>MORFEInvariantManifold.find_position_g</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>find<em>position</em>g(j::Int64,p::Int64,ndofs::Int64,index_comb::Array{Int64})</p></blockquote><p>It finds the maps position to compute their contribution to the quadratic nonlinearities.</p><ul><li>j : counter</li><li>p : order</li><li>ndofs : number of degrees of freedom</li><li>index_comb : reference monomials exponentials</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.find_position_h-Tuple{Int64, Int64, Int64, Int64, Array{Int64, N} where N}" href="#MORFEInvariantManifold.find_position_h-Tuple{Int64, Int64, Int64, Int64, Array{Int64, N} where N}"><code>MORFEInvariantManifold.find_position_h</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>find<em>position</em>g(j::Int64,k::Int64,p::Int64,ndofs::Int64,index_comb::Array{Int64})</p></blockquote><p>It finds the maps position to compute their contribution to the cubic nonlinearities.</p><ul><li>j : counter</li><li>k : counter</li><li>p : order</li><li>ndofs : number of degrees of freedom</li><li>index_comb : reference monomials exponentials</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.generate_conj!-NTuple{7, Any}" href="#MORFEInvariantManifold.generate_conj!-NTuple{7, Any}"><code>MORFEInvariantManifold.generate_conj!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>generate_conj!(conj,comb,cmap,ndofs,p,combs,nc)</p></blockquote><p>It maps entries to their conjugate</p><ul><li>conj : conjugate</li><li>comb : matrix that stores the powers of the monomials</li><li>cmap : total combinations map</li><li>ndofs : number of degrees of freedom</li><li>p : order of the asymptotic expansion</li><li>combs : combinations</li><li>nc : number of combinations</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.generate_pmap!-Tuple{Matrix{Int64}, Array{Int64, N} where N, Int64, Int64, Array{Int64, N} where N, Array{Int64, N} where N, Int64}" href="#MORFEInvariantManifold.generate_pmap!-Tuple{Matrix{Int64}, Array{Int64, N} where N, Int64, Int64, Array{Int64, N} where N, Array{Int64, N} where N, Int64}"><code>MORFEInvariantManifold.generate_pmap!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>generate<em>pmap!(comb::Matrix{Int64},cmap::Array{Int64},ndofs::Int64,p::Int64,combs::Array{Int64},sorted</em>combs::Array{Int64},counter::Int64)</p></blockquote><p>It computes combinations maps to account for indexes permutations.</p><ul><li>comb : matrix that stores the powers of the monomials</li><li>cmap : total combinations map</li><li>ndofs : number of degrees of freedom</li><li>p : order of the asymptotic expansion</li><li>combs : combinations</li><li>sorted_combs : sorted combinations</li><li>counter : recursion depth</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.get_coor!-Tuple{MORFEInvariantManifold.Grid, SubArray{Int64, 1, Vector{Int64}, Tuple{UnitRange{Int64}}, true}, Vector{Float64}, Int64}" href="#MORFEInvariantManifold.get_coor!-Tuple{MORFEInvariantManifold.Grid, SubArray{Int64, 1, Vector{Int64}, Tuple{UnitRange{Int64}}, true}, Vector{Float64}, Int64}"><code>MORFEInvariantManifold.get_coor!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>get_coor!(mesh::Grid, conn::SubArray{Int64, 1, Vector{Int64}, Tuple{UnitRange{Int64}}, true}, X::Vector{Float64}, nn::Int64)</p></blockquote><p>it retrieves element nodes coordinates. </p><ul><li>mesh : Grid </li><li>conn : connectivity of the element</li><li>X : coordinates of the nodes in {x₁, y₁, z₁, ..., xₙ, yₙ, zₙ} format</li><li>nn : number of nodes</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.get_coor!-Tuple{MORFEInvariantManifold.Grid, Vector{Int64}, Vector{Float64}, Int64}" href="#MORFEInvariantManifold.get_coor!-Tuple{MORFEInvariantManifold.Grid, Vector{Int64}, Vector{Float64}, Int64}"><code>MORFEInvariantManifold.get_coor!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>get_coor!(mesh::Grid, conn::Vector{Int64}, X::Vector{Float64}, nn::Int64)</p></blockquote><p>it retrieves element nodes coordinates. </p><ul><li>mesh : Grid </li><li>conn : connectivity of the element</li><li>X : coordinates of the nodes in {x₁, y₁, z₁, ..., xₙ, yₙ, zₙ} format</li><li>nn : number of nodes</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.get_materials_path-Tuple{}" href="#MORFEInvariantManifold.get_materials_path-Tuple{}"><code>MORFEInvariantManifold.get_materials_path</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>get<em>materials</em>path()</p></blockquote><p>It returns the path associated to the material database <strong>return</strong>  pth::String</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.get_node_connectivity-Tuple{MORFEInvariantManifold.NodalConnectivity, Int64}" href="#MORFEInvariantManifold.get_node_connectivity-Tuple{MORFEInvariantManifold.NodalConnectivity, Int64}"><code>MORFEInvariantManifold.get_node_connectivity</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>NodalConnectivity(n2n::NodalConnectivity, node::Int64)</p></blockquote><p>It returns a View containing which nodes are connector to node</p><ul><li>n2n : NodalConnectivity structure</li><li>node : node of interest</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.identity_tangency!-Tuple{MORFEInvariantManifold.Parametrisation, Int64, Int64, Array{Int64, N} where N, Matrix{Float64}, Array{Float64, N} where N, Array{Float64, N} where N, MORFEInvariantManifold.Field}" href="#MORFEInvariantManifold.identity_tangency!-Tuple{MORFEInvariantManifold.Parametrisation, Int64, Int64, Array{Int64, N} where N, Matrix{Float64}, Array{Float64, N} where N, Array{Float64, N} where N, MORFEInvariantManifold.Field}"><code>MORFEInvariantManifold.identity_tangency!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>identity_tangency!(Cp::Parametrisation,nm::Int64,neq::Int64,Φₗᵢₛₜ::Array{Int64},ϕ::Matrix{ComplexF64},ω₀::Array{Float64},ζ₀::Array{Float64})</p></blockquote><p>It fills the first order parametrization using eigenmodes and eigenvalues of the mechanical problem.</p><ul><li>Cp : Parametrisation data structure</li><li>nm : number of master modes</li><li>neq : total number of equations</li><li>Φₗᵢₛₜ : master modes list</li><li>ϕ : modes</li><li>ω₀ : eigenfrequencies</li><li>ζ₀ : damping coefficients</li><li>U : displacement field</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.import_mesh!-Tuple{MORFEInvariantManifold.Grid, String, Any, Any, Vector{String}, Vector{Vector{Int64}}, Vector{Vector{Float64}}, Type{Val{:MED}}}" href="#MORFEInvariantManifold.import_mesh!-Tuple{MORFEInvariantManifold.Grid, String, Any, Any, Vector{String}, Vector{Vector{Int64}}, Vector{Vector{Float64}}, Type{Val{:MED}}}"><code>MORFEInvariantManifold.import_mesh!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>import<em>mesh!( mesh::Grid, mesh</em>file::String, Ω<em>list::Vector{Vector{Int64}}, Γ</em>list::Vector{Vector{Int64}}, mat::Vector{material}, bc<em>dof::Vector{Vector{Int64}}, bc</em>vals::Vector{Vector{Float64}}, ::Type{Val{:MED}})</p></blockquote><p>It reads a MED mesh format</p><ul><li>mesh_file : name of the mesh file</li><li>Ω_list : list of domains in which the structures is organised</li><li>Γ_list : list of boundaries</li><li>mat : list of materials associated to each domain</li><li>bc_dof : list of constrained degrees of freedom of each boundary</li><li>bc_vals : boundary condition values</li><li>:MED : specializes function to read MED mesh format</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.increment_field!-Tuple{MORFEInvariantManifold.Field, Vector{Float64}}" href="#MORFEInvariantManifold.increment_field!-Tuple{MORFEInvariantManifold.Field, Vector{Float64}}"><code>MORFEInvariantManifold.increment_field!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>increment_field!(ϕ::Field,U::Vector{Float64})</p></blockquote><p>it increments field values. ϕ.val += U</p><ul><li>ϕ : field to update</li><li>U : solution vector</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.init_rdyn-Tuple{Any}" href="#MORFEInvariantManifold.init_rdyn-Tuple{Any}"><code>MORFEInvariantManifold.init_rdyn</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>init_rdyn(ndofs)</p></blockquote><p>It initializes the real-valued reduced dynamics in a format compatible with MATCONT</p><ul><li>ndofs : number of degrees of freedom</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.init_realification_matrix-Tuple{Int64}" href="#MORFEInvariantManifold.init_realification_matrix-Tuple{Int64}"><code>MORFEInvariantManifold.init_realification_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>init<em>realification</em>matrix(ndofs::Int64)</p></blockquote><p>It initializes the matrix used to realify the system</p><ul><li></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.init_symCSC-Tuple{MORFEInvariantManifold.Grid, MORFEInvariantManifold.Field, MORFEInvariantManifold.NodalConnectivity, Int64, String}" href="#MORFEInvariantManifold.init_symCSC-Tuple{MORFEInvariantManifold.Grid, MORFEInvariantManifold.Field, MORFEInvariantManifold.NodalConnectivity, Int64, String}"><code>MORFEInvariantManifold.init_symCSC</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>init_symCSC(mesh::Grid, ϕ::Field, n2n::NodalConnectivity, naux::Int64, tp::String)</p></blockquote><p>It initializes a symmetric CSC matrix from a field. It eventually add auxiliary equations.</p><ul><li>mesh : Grid</li><li>ϕ : field of interest </li><li>nn : number of queries</li><li>n2n : node-to-node connectivity</li><li>naux : number of auxiliary equations</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.initialize_parametrisation!" href="#MORFEInvariantManifold.initialize_parametrisation!"><code>MORFEInvariantManifold.initialize_parametrisation!</code></a> — <span class="docstring-category">Function</span></header><section><div><blockquote><p>initialize_parametrisation!(param,order,ndofs,neq)</p></blockquote><p>It initializes a generic order of the asymptotic expansion</p><ul><li>param : parametrisation</li><li>order : order</li><li>ndofs : number of degrees of freedom of the reduced model</li><li>neq   : number of equations</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.integrate_MK!-Tuple{Matrix{Float64}, Matrix{Float64}, Array{Float64, N} where N, Float64, Matrix{Float64}, Vector{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Int64, Symbol, Any}" href="#MORFEInvariantManifold.integrate_MK!-Tuple{Matrix{Float64}, Matrix{Float64}, Array{Float64, N} where N, Float64, Matrix{Float64}, Vector{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Int64, Symbol, Any}"><code>MORFEInvariantManifold.integrate_MK!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>integrate_MK!(Mₑ::Matrix{Float64},Kₑ::Matrix{Float64},X::Array{Float64},</p></blockquote><p>ρ::Float64,Dᵢⱼₖₗ::Matrix{Float64}, N::Array{Float64},∂N∂a::Matrix{Float64},∂N∂x::Matrix{Float64}, sym∇::Matrix{Float64},Jac::Matrix{Float64}, Jac⁻¹::Matrix{Float64},nn,etype::Symbol) It integrates elemental and stiffness matrices</p><ul><li>Mₑ : elemental mass matrix</li><li>Kₑ : elemental stiffness matrix</li><li>X  : nodal coordinates</li><li>ρ : density</li><li>Dᵢⱼₖₗ : elasticity tensor</li><li>N : shape functions</li><li>∂N∂a : shape functions master derivatives</li><li>∂N∂x : shape functions sparial derivatives</li><li>sym∇ : 0.5*(∇(⋅)+ ∇ᵀ(⋅))</li><li>Jac : ∂x∂a</li><li>Jac⁻¹: ∂a∂x</li><li>nn : nodes number</li><li>etype : element type</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.list_materials-Tuple{}" href="#MORFEInvariantManifold.list_materials-Tuple{}"><code>MORFEInvariantManifold.list_materials</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>list_materials()</p></blockquote><p>It lists all materials in the database. <strong>return</strong>  <em>nothing</em></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.load_material-Tuple{String}" href="#MORFEInvariantManifold.load_material-Tuple{String}"><code>MORFEInvariantManifold.load_material</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>load_material( name::String )</p></blockquote><p>It loads the data structure from the database</p><ul><li>name : name of the material to load</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.make_output_dir-Tuple{String}" href="#MORFEInvariantManifold.make_output_dir-Tuple{String}"><code>MORFEInvariantManifold.make_output_dir</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>make<em>output</em>dir(mesh_file::String)</p></blockquote><p>It creates the folder that stores the output of the analysis</p><ul><li>mesh_file : name of the mesh file</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.mass_normalization!-Tuple{Any, Any, Any}" href="#MORFEInvariantManifold.mass_normalization!-Tuple{Any, Any, Any}"><code>MORFEInvariantManifold.mass_normalization!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>mass_normalization!(ϕ,M,neig)</p></blockquote><p>Modes are normalised such that ϕᵢMϕⱼ=δᵢⱼ</p><ul><li>ϕ : eigenmodes</li><li>M : mass matrix</li><li>neig : number of computed eigenvalues</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.metric!-Tuple{Array{Float64, N} where N, Matrix{Float64}, Matrix{Float64}, Int64, Matrix{Float64}, Matrix{Float64}}" href="#MORFEInvariantManifold.metric!-Tuple{Array{Float64, N} where N, Matrix{Float64}, Matrix{Float64}, Int64, Matrix{Float64}, Matrix{Float64}}"><code>MORFEInvariantManifold.metric!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>metric!(X::Array{Float64},∂N∂a::Matrix{Float64},</p></blockquote><pre><code class="nohighlight hljs">      ∂N∂x::Matrix{Float64},nn::Int64,
      Jac::Matrix{Float64},Jac⁻¹::Matrix{Float64})</code></pre><p>It computes element metric</p><ul><li>X  : nodal coordinates</li><li>∂N∂a : shape functions master derivatives</li><li>∂N∂x : shape functions sparial derivatives</li><li>nn : nodes number</li><li>Jac : ∂x∂a</li><li>Jac⁻¹: ∂a∂x</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.print_cell_nodes-Tuple{Any, Any, Any, Any, Any, Type{Val{:H20}}}" href="#MORFEInvariantManifold.print_cell_nodes-Tuple{Any, Any, Any, Any, Any, Type{Val{:H20}}}"><code>MORFEInvariantManifold.print_cell_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>print<em>cell</em>type(io,iΩ,set,::Type{Val{:H20}})</p></blockquote><p>It writes to the output file the nodes of an element .vtk format.</p><ul><li>io : file handler</li><li>iΩ : reference domain</li><li>set : reference element number</li><li>::Type{Val{:H20}} : twenty-nodes quadratic hexahedron identifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.print_cell_nodes-Tuple{Any, Any, Any, Any, Any, Type{Val{:H27}}}" href="#MORFEInvariantManifold.print_cell_nodes-Tuple{Any, Any, Any, Any, Any, Type{Val{:H27}}}"><code>MORFEInvariantManifold.print_cell_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>print<em>cell</em>type(io,iΩ,set,::Type{Val{:H27}})</p></blockquote><p>It writes to the output file the nodes of an element .vtk format.</p><ul><li>io : file handler</li><li>iΩ : reference domain</li><li>set : reference element number</li><li>::Type{Val{:H27}} : twentyseven-nodes quadratic hexahedron identifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.print_cell_nodes-Tuple{Any, Any, Any, Any, Any, Type{Val{:HE8}}}" href="#MORFEInvariantManifold.print_cell_nodes-Tuple{Any, Any, Any, Any, Any, Type{Val{:HE8}}}"><code>MORFEInvariantManifold.print_cell_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>print<em>cell</em>type(io,iΩ,set,::Type{Val{:HE8}})</p></blockquote><p>It writes to the output file the nodes of an element .vtk format.</p><ul><li>io : file handler</li><li>iΩ : reference domain</li><li>set : reference element number</li><li>::Type{Val{:HE8}} : eight-nodes linear hexahedron identifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.print_cell_nodes-Tuple{Any, Any, Any, Any, Any, Type{Val{:P15}}}" href="#MORFEInvariantManifold.print_cell_nodes-Tuple{Any, Any, Any, Any, Any, Type{Val{:P15}}}"><code>MORFEInvariantManifold.print_cell_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>print<em>cell</em>type(io,iΩ,set,::Type{Val{:P15}})</p></blockquote><p>It writes to the output file the nodes of an element .vtk format.</p><ul><li>io : file handler</li><li>iΩ : reference domain</li><li>set : reference element number</li><li>::Type{Val{:P15}} : fifteen-nodes quadratic prism identifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.print_cell_nodes-Tuple{Any, Any, Any, Any, Any, Type{Val{:P18}}}" href="#MORFEInvariantManifold.print_cell_nodes-Tuple{Any, Any, Any, Any, Any, Type{Val{:P18}}}"><code>MORFEInvariantManifold.print_cell_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>print<em>cell</em>type(io,iΩ,set,::Type{Val{:P18}})</p></blockquote><p>It writes to the output file the nodes of an element .vtk format.</p><ul><li>io : file handler</li><li>iΩ : reference domain</li><li>set : reference element number</li><li>::Type{Val{:P18}} : eighteen-nodes quadratic prism identifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.print_cell_nodes-Tuple{Any, Any, Any, Any, Any, Type{Val{:PE6}}}" href="#MORFEInvariantManifold.print_cell_nodes-Tuple{Any, Any, Any, Any, Any, Type{Val{:PE6}}}"><code>MORFEInvariantManifold.print_cell_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>print<em>cell</em>type(io,iΩ,set,::Type{Val{:PE6}})</p></blockquote><p>It writes to the output file the nodes of an element .vtk format.</p><ul><li>io : file handler</li><li>iΩ : reference domain</li><li>set : reference element number</li><li>::Type{Val{:PE6}} : six-nodes linear prism identifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.print_cell_nodes-Tuple{Any, Any, Any, Any, Any, Type{Val{:T10}}}" href="#MORFEInvariantManifold.print_cell_nodes-Tuple{Any, Any, Any, Any, Any, Type{Val{:T10}}}"><code>MORFEInvariantManifold.print_cell_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>print<em>cell</em>type(io,iΩ,set,::Type{Val{:T10}})</p></blockquote><p>It writes to the output file the nodes of an element .vtk format.</p><ul><li>io : file handler</li><li>iΩ : reference domain</li><li>set : reference element number</li><li>::Type{Val{:T10}} : ten-nodes quadratic tetrahedron identifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.print_cell_nodes-Tuple{Any, Any, Any, Any, Any, Type{Val{:TE4}}}" href="#MORFEInvariantManifold.print_cell_nodes-Tuple{Any, Any, Any, Any, Any, Type{Val{:TE4}}}"><code>MORFEInvariantManifold.print_cell_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>print<em>cell</em>type(io,iΩ,set,::Type{Val{:TE4}})</p></blockquote><p>It writes to the output file the nodes of an element .vtk format.</p><ul><li>io : file handler</li><li>iΩ : reference domain</li><li>set : reference element number</li><li>::Type{Val{:TE4}} : four-nodes linear tetrahedron identifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.print_cell_type-Tuple{Any, Any, Any, Type{Val{:H20}}}" href="#MORFEInvariantManifold.print_cell_type-Tuple{Any, Any, Any, Type{Val{:H20}}}"><code>MORFEInvariantManifold.print_cell_type</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>print<em>cell</em>type(io,iΩ,set,::Type{Val{:H20}})</p></blockquote><p>It writes to the output file the correct cell type assuming .vtk format.</p><ul><li>io : file handler</li><li>iΩ : reference domain</li><li>set : reference element number</li><li>::Type{Val{:H20}} : twenty-nodes quadratic hexahedron identifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.print_cell_type-Tuple{Any, Any, Any, Type{Val{:H27}}}" href="#MORFEInvariantManifold.print_cell_type-Tuple{Any, Any, Any, Type{Val{:H27}}}"><code>MORFEInvariantManifold.print_cell_type</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>print<em>cell</em>type(io,iΩ,set,::Type{Val{:H27}})</p></blockquote><p>It writes to the output file the correct cell type assuming .vtk format.</p><ul><li>io : file handler</li><li>iΩ : reference domain</li><li>set : reference element number</li><li>::Type{Val{:H27}} : twentyseven-nodes quadratic hexahedron identifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.print_cell_type-Tuple{Any, Any, Any, Type{Val{:HE8}}}" href="#MORFEInvariantManifold.print_cell_type-Tuple{Any, Any, Any, Type{Val{:HE8}}}"><code>MORFEInvariantManifold.print_cell_type</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>print<em>cell</em>type(io,iΩ,set,::Type{Val{:HE8}})</p></blockquote><p>It writes to the output file the correct cell type assuming .vtk format.</p><ul><li>io : file handler</li><li>iΩ : reference domain</li><li>set : reference element number</li><li>::Type{Val{:HE8}} : eight-nodes lienar hexahedron identifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.print_cell_type-Tuple{Any, Any, Any, Type{Val{:P15}}}" href="#MORFEInvariantManifold.print_cell_type-Tuple{Any, Any, Any, Type{Val{:P15}}}"><code>MORFEInvariantManifold.print_cell_type</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>print<em>cell</em>type(io,iΩ,set,::Type{Val{:P15}})</p></blockquote><p>It writes to the output file the correct cell type assuming .vtk format.</p><ul><li>io : file handler</li><li>iΩ : reference domain</li><li>set : reference element number</li><li>::Type{Val{:P15}} : fifteen-nodes quadratic prism identifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.print_cell_type-Tuple{Any, Any, Any, Type{Val{:P18}}}" href="#MORFEInvariantManifold.print_cell_type-Tuple{Any, Any, Any, Type{Val{:P18}}}"><code>MORFEInvariantManifold.print_cell_type</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>print<em>cell</em>type(io,iΩ,set,::Type{Val{:P18}})</p></blockquote><p>It writes to the output file the correct cell type assuming .vtk format.</p><ul><li>io : file handler</li><li>iΩ : reference domain</li><li>set : reference element number</li><li>::Type{Val{:P18}} : fifteen-nodes quadratic prism identifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.print_cell_type-Tuple{Any, Any, Any, Type{Val{:PE6}}}" href="#MORFEInvariantManifold.print_cell_type-Tuple{Any, Any, Any, Type{Val{:PE6}}}"><code>MORFEInvariantManifold.print_cell_type</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>print<em>cell</em>type(io,iΩ,set,::Type{Val{:PE6}})</p></blockquote><p>It writes to the output file the correct cell type assuming .vtk format.</p><ul><li>io : file handler</li><li>iΩ : reference domain</li><li>set : reference element number</li><li>::Type{Val{:PE6}} : six-nodes lienar prism identifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.print_cell_type-Tuple{Any, Any, Any, Type{Val{:T10}}}" href="#MORFEInvariantManifold.print_cell_type-Tuple{Any, Any, Any, Type{Val{:T10}}}"><code>MORFEInvariantManifold.print_cell_type</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>print<em>cell</em>type(io,iΩ,set,::Type{Val{:T10}})</p></blockquote><p>It writes to the output file the correct cell type assuming .vtk format.</p><ul><li>io : file handler</li><li>iΩ : reference domain</li><li>set : reference element number</li><li>::Type{Val{:T10}} : ten-nodes quadratic tetrahedron identifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.print_cell_type-Tuple{Any, Any, Any, Type{Val{:TE4}}}" href="#MORFEInvariantManifold.print_cell_type-Tuple{Any, Any, Any, Type{Val{:TE4}}}"><code>MORFEInvariantManifold.print_cell_type</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>print<em>cell</em>type(io,iΩ,set,::Type{Val{:TE4}})</p></blockquote><p>It writes to the output file the correct cell type assuming .vtk format.</p><ul><li>io : file handler</li><li>iΩ : reference domain</li><li>set : reference element number</li><li>::Type{Val{:TE4}} : four-nodes linear tetrahedron identifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.read_mesh-Tuple{String, Any, Any, Vector{String}, Vector{Vector{Int64}}, Vector{Vector{Float64}}}" href="#MORFEInvariantManifold.read_mesh-Tuple{String, Any, Any, Vector{String}, Vector{Vector{Int64}}, Vector{Vector{Float64}}}"><code>MORFEInvariantManifold.read_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>read<em>mesh( mesh</em>file::String, Ω<em>list::Vector{Vector{Int64}}, Γ</em>list::Vector{Vector{Int64}}, mat::Vector{material}, bc<em>dof::Vector{Vector{Int64}}, bc</em>vals::Vector{Vector{Float64}})</p></blockquote><p>It reads the mesh file and it inializes the grid data structure</p><ul><li>mesh_file : name of the mesh file to read</li><li>Ω_list : list of domains in which the structures is organised</li><li>Γ_list : list of boundaries</li><li>mat : list of materials associated to each domain</li><li>bc_dof : list of constrained degrees of freedom of each boundary</li><li>bc_vals : boundary condition values</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.realification!-NTuple{7, Any}" href="#MORFEInvariantManifold.realification!-NTuple{7, Any}"><code>MORFEInvariantManifold.realification!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>realification!(Cp,Wr,fr,p,ndofs,neq,rmat)</p></blockquote><p>It realifies mappings and reduced dynamics for an order p of the parametrisation</p><ul><li>Cp : Parametrisation data structure</li><li>Wr : real-valued mapping</li><li>fr : real-valued reduced dynamics</li><li>p : order of the asymptotic development</li><li>ndofs : number of degrees of freedom</li><li>neq : number of equations</li><li>rmat : realification matrix R</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.recursive_assembly!" href="#MORFEInvariantManifold.recursive_assembly!"><code>MORFEInvariantManifold.recursive_assembly!</code></a> — <span class="docstring-category">Function</span></header><section><div><blockquote><p>recursive_assembly!(Cp,ndofs,p,mesh,U,ic,cc,nls=0)</p></blockquote><p>It assembles all right hand sides of the homological equations for a given order p of the expansion of the ε⁰ development</p><ul><li>Cp : parametrisation data structure</li><li>ndofs : number of degrees of freedom</li><li>p : order of the asymptotic development</li><li>mesh : mesh data structure</li><li>U : dispalcement field</li><li>ic : index combination of a given monomial</li><li>cc : counter of the asymptotic development</li><li>nls : tag for the nonlinear static analysis. 0 = yes, 1 = yes</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.recursive_assembly_veps!" href="#MORFEInvariantManifold.recursive_assembly_veps!"><code>MORFEInvariantManifold.recursive_assembly_veps!</code></a> — <span class="docstring-category">Function</span></header><section><div><blockquote><p>recursive<em>assembly</em>veps!(Cp,Cp⁺,ndofs,p,mesh,U,Cic,cc,nls=0)</p></blockquote><p>It assembles right hand sides of all homological equations for a given order p of the expansion.</p><ul><li>Cp : autonomous parametrisation data structure</li><li>Cp⁺ :  non-auonomous parametrisation data structure</li><li>ndofs : number of degrees of freedom</li><li>p : order of the asymptotic development</li><li>mesh : grid data structure</li><li>U : displacement field</li><li>Cic : monomials index combination</li><li>cc : recursion depth</li><li>nls : nonlinear static solution. 0 = no, 1 = yes.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.recursive_pm!-NTuple{11, Any}" href="#MORFEInvariantManifold.recursive_pm!-NTuple{11, Any}"><code>MORFEInvariantManifold.recursive_pm!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>recursive<em>pm!(Cp,Wr,fr,Cic,Ric,pm</em>comb,p,ndofs,neq,comb,cc)</p></blockquote><p>It realifies mappings and reduced dynamics of a given index combination comb of order p.</p><ul><li>Cp : parametrisation data structure</li><li>Wr : real-valued mappings</li><li>fr : real-valued reduced dynamics</li><li>Cic : complex-valued parametrisation index combination of a given monomial</li><li>Ric : real-valued parametrisation index combination of a given monomial</li><li>pm_comb : +- combinations</li><li>p : order of the asymptotic development</li><li>ndofs : number of degrees of freedom</li><li>neq : number of equations</li><li>comb : reference index combination of the realified monomial</li><li>cc : recursion depth</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.save_matcont_rdyn-Tuple{Any, Any, Any}" href="#MORFEInvariantManifold.save_matcont_rdyn-Tuple{Any, Any, Any}"><code>MORFEInvariantManifold.save_matcont_rdyn</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>save<em>matcont</em>rdyn(rdyn,ndofs,outdir)</p></blockquote><p>It saves the autonomous reduced dynamics in a format suitable for matcont GUI usage.</p><ul><li>rdyn : reduced dynamics in matcont format style</li><li>ndofs : number of degrees of freedom</li><li>outdir : output directory</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.save_matcont_rdyn_nonautonomous-NTuple{4, Any}" href="#MORFEInvariantManifold.save_matcont_rdyn_nonautonomous-NTuple{4, Any}"><code>MORFEInvariantManifold.save_matcont_rdyn_nonautonomous</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>save<em>matcont</em>rdyn(rdyn,ndofs,outdir)</p></blockquote><p>It saves the non-autonomous reduced dynamics in a format suitable for matcont GUI usage.</p><ul><li>rdyn : reduced dynamics in matcont format style</li><li>ndofs : number of degrees of freedom</li><li>outdir : output directory</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.solve_homological!-NTuple{11, Any}" href="#MORFEInvariantManifold.solve_homological!-NTuple{11, Any}"><code>MORFEInvariantManifold.solve_homological!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>solve<em>homological!(Cp,ndofs,p,sys</em>mat,sys<em>rhs,sys</em>res,ic,style,M,C,K)</p></blockquote><p>It solves al homological equations for a given order of the asymtptotic developmet of the ε⁰-invariance.</p><ul><li>Cp : parametrisation structure</li><li>ndofs : number of degrees of freedom</li><li>p : order of the asymptotic developmet</li><li>sys_mat : matrix used to solve the homological equations</li><li>sys_rhs : right hand side of the homological equations</li><li>sys_res : residual of the homological equations</li><li>ic : index combination</li><li>style : parametrisation style</li><li>M : mass matrix</li><li>C : damping matrix</li><li>K : stiffness matrix</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.solve_homological_veps!-NTuple{13, Any}" href="#MORFEInvariantManifold.solve_homological_veps!-NTuple{13, Any}"><code>MORFEInvariantManifold.solve_homological_veps!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>solve<em>homological</em>veps!(η,Cp,Cp⁺,ndofs,p,sys<em>mat,sys</em>rhs,sys_res,style,ic,M,C,K)</p></blockquote><p>It solves al homological equations for a given order of the asymtptotic developmet of the ε¹-invariance.</p><ul><li>η : eigenvalue associated to the non-autonomous forcing</li><li>Cp : autonomous parametrisation data structure</li><li>Cp⁺ :  non-auonomous parametrisation data structure</li><li>ndofs : number of degrees of freedom</li><li>p : order of the asymptotic development</li><li>sys_mat : homological equation matrix</li><li>sys_rhs : homological equation right hand side</li><li>sys_res : homological equation residual</li><li>style : parametrisation style</li><li>ic : index combination</li><li>M : mass matrix</li><li>C : damping matrix</li><li>K : stiffness matrix</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.structure_odir" href="#MORFEInvariantManifold.structure_odir"><code>MORFEInvariantManifold.structure_odir</code></a> — <span class="docstring-category">Function</span></header><section><div><blockquote><p>structure_odir(odir::String, id::Int64, tag = &#39;a&#39;)</p></blockquote><p>It creates the sub-folders that stores the output of the analysis</p><ul><li>odir : global output folder path</li><li>id : number of computed step. Autonomous is zero, non-autonomous in increasing order</li><li>tag : &#39;a&#39; = autonomous, &#39;na&#39; = non-autonomous</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.update_field!-Tuple{MORFEInvariantManifold.Field, Vector{Float64}}" href="#MORFEInvariantManifold.update_field!-Tuple{MORFEInvariantManifold.Field, Vector{Float64}}"><code>MORFEInvariantManifold.update_field!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>update_field!(ϕ::Field,U::Vector{Float64})</p></blockquote><p>it overwrites free dofs values using the solution U</p><ul><li>ϕ : field to update</li><li>U : solution vector</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.∂N∂a!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:H20}}}" href="#MORFEInvariantManifold.∂N∂a!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:H20}}}"><code>MORFEInvariantManifold.∂N∂a!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>∂N∂a!(∂N∂a::Array{Float64},gp::Tuple,::Type{Val{:H20}})</p></blockquote><p>It fills ∂N∂a with the derivatives of the shape functions of a T4 element evaluated at gauss point gp.</p><ul><li>∂N∂a : shape functions derivatives Array</li><li>gp : gauss point coordinates</li><li>:Type{Val{:H20}} : element type specifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.∂N∂a!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:H27}}}" href="#MORFEInvariantManifold.∂N∂a!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:H27}}}"><code>MORFEInvariantManifold.∂N∂a!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>∂N∂a!(∂N∂a::Array{Float64},gp::Tuple,::Type{Val{:H27}})</p></blockquote><p>It fills ∂N∂a with the derivatives of the shape functions of a T4 element evaluated at gauss point gp.</p><ul><li>∂N∂a : shape functions derivatives Array</li><li>gp : gauss point coordinates</li><li>:Type{Val{:H27}} : element type specifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.∂N∂a!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:HE8}}}" href="#MORFEInvariantManifold.∂N∂a!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:HE8}}}"><code>MORFEInvariantManifold.∂N∂a!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>∂N∂a!(∂N∂a::Array{Float64},gp::Tuple,::Type{Val{:HE8}})</p></blockquote><p>It fills ∂N∂a with the derivatives of the shape functions of a H8 element evaluated at gauss point gp.</p><ul><li>∂N∂a : shape functions derivatives Array</li><li>gp : gauss point coordinates</li><li>:Type{Val{:HE8}} : element type specifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.∂N∂a!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:P15}}}" href="#MORFEInvariantManifold.∂N∂a!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:P15}}}"><code>MORFEInvariantManifold.∂N∂a!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>∂N∂a!(∂N∂a::Array{Float64},gp::Tuple,::Type{Val{:P15}})</p></blockquote><p>It fills ∂N∂a with the derivatives of the shape functions of a T4 element evaluated at gauss point gp.</p><ul><li>∂N∂a : shape functions derivatives Array</li><li>gp : gauss point coordinates</li><li>:Type{Val{:P15}} : element type specifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.∂N∂a!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:P18}}}" href="#MORFEInvariantManifold.∂N∂a!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:P18}}}"><code>MORFEInvariantManifold.∂N∂a!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>∂N∂a!(∂N∂a::Array{Float64},gp::Tuple,::Type{Val{:P18}})</p></blockquote><p>It fills ∂N∂a with the derivatives of the shape functions of a T4 element evaluated at gauss point gp.</p><ul><li>∂N∂a : shape functions derivatives Array</li><li>gp : gauss point coordinates</li><li>:Type{Val{:P18}} : element type specifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.∂N∂a!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:PE6}}}" href="#MORFEInvariantManifold.∂N∂a!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:PE6}}}"><code>MORFEInvariantManifold.∂N∂a!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>∂N∂a!(∂N∂a::Array{Float64},gp::Tuple,::Type{Val{:PE6}})</p></blockquote><p>It fills ∂N∂a with the derivatives of the shape functions of a T4 element evaluated at gauss point gp.</p><ul><li>∂N∂a : shape functions derivatives Array</li><li>gp : gauss point coordinates</li><li>:Type{Val{:PE6}} : element type specifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.∂N∂a!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:T10}}}" href="#MORFEInvariantManifold.∂N∂a!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:T10}}}"><code>MORFEInvariantManifold.∂N∂a!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>∂N∂a!(∂N∂a::Array{Float64},gp::Tuple,::Type{Val{:T10}})</p></blockquote><p>It fills ∂N∂a with the derivatives of the shape functions of a T4 element evaluated at gauss point gp.</p><ul><li>∂N∂a : shape functions derivatives Array</li><li>gp : gauss point coordinates</li><li>:Type{Val{:T10}} : element type specifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.∂N∂a!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:TE4}}}" href="#MORFEInvariantManifold.∂N∂a!-Tuple{Array{Float64, N} where N, Tuple, Type{Val{:TE4}}}"><code>MORFEInvariantManifold.∂N∂a!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>∂N∂a!(∂N∂a::Array{Float64},gp::Tuple,::Type{Val{:TE4}})</p></blockquote><p>It fills ∂N∂a with the derivatives of the shape functions of a T4 element evaluated at gauss point gp.</p><ul><li>∂N∂a : shape functions derivatives Array</li><li>gp : gauss point coordinates</li><li>:Type{Val{:TE4}} : element type specifier</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MORFEInvariantManifold.∂N∂a27!-Tuple{Array{Float64, N} where N, Tuple}" href="#MORFEInvariantManifold.∂N∂a27!-Tuple{Array{Float64, N} where N, Tuple}"><code>MORFEInvariantManifold.∂N∂a27!</code></a> — <span class="docstring-category">Method</span></header><section><div><blockquote><p>∂N∂a!(∂N∂a::Array{Float64},gp::Tuple,::Type{Val{:H27}})</p></blockquote><p>It fills ∂N∂a with the derivatives of the shape functions of a T4 element evaluated at gauss point gp.</p><ul><li>∂N∂a : shape functions derivatives Array</li><li>gp : gauss point coordinates</li><li>:Type{Val{:H27}} : element type specifier</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../integrators/">« Integrators</a><a class="docs-footer-nextpage" href="../authors/">Authors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Sunday 13 February 2022 22:52">Sunday 13 February 2022</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
